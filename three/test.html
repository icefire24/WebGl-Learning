//threejs demo
//https://threejs.org/examples/#webgl_animation_cloth
//https://threejs.org/examples/#webgl_animation_cloth
//https://threejs.org/examples/#webgl_animation_cloth
<html>
<head>
    <title>three.js webgl -</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.152.2/three.js"  crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <script>
        // 创建一个Three.js场景
var scene = new THREE.Scene();

// 创建一个几何体
var geometry = new THREE.BoxGeometry(5, 5, 5);
var material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
var cube = new THREE.Mesh(geometry, material);
cube.name = "cube1";
scene.add(cube);

var geometry2 = new THREE.BoxGeometry(5, 5, 5);
var material2 = new THREE.MeshBasicMaterial({ color: 0xffff00 });
var cube2 = new THREE.Mesh(geometry2, material2);
cube2.position.set(10,  0,  0);
cube2.name = "cube2";
scene.add(cube2);
// 创建一个透视相机
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
//camera.position.z = 5;


// var camera = new THREE.PerspectiveCamera(75, 1, 0.1, 2000);
camera.position.set(100,100,100);
camera.lookAt(0,0,0);
const axesHelper = new THREE.AxesHelper(500);
scene.add(axesHelper);

// var matrix = [-3.2335585754263394, 2.11450102579358, 1.555820659391571, 1.5447923262818193, -2.6778734943516582, -2.5532807801131847, -1.8786687442899896, -1.8653519236205616, 2.3306029779505383e-16, 7.265899130365567, -1.1129459729813873, -1.1050569281553626, 0, 0, 1113.218294069171, 1135.5000000074506];
// const m = new THREE.Matrix4().fromArray(matrix);
// camera.projectionMatrix = m;

// 创建一个渲染器
var renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 鼠标点击事件处理函数
function onMouseClick(event) {
    // 计算鼠标点击位置的标准化设备坐标
    var mouse = new THREE.Vector2();
    mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
    mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
    console.log(mouse);
    // 创建一个Raycaster对象
    var raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    

    // 检测与点击位置相交的对象
    var intersects = raycaster.intersectObjects(scene.children);

    // 如果有相交的对象，则执行点击操作
    if (intersects.length > 0) {
        //console.log("点击了对象:", intersects[0].object);
        //console.log("点击了对象:", intersects[0].object.name);
        for (var i = 0; i < intersects.length; i++) {
            console.log("点击了对象:", intersects[i].object);
        }
    }
}

// 监听鼠标点击事件
window.addEventListener('click', onMouseClick, false);

// 渲染循环
function animate() {
    requestAnimationFrame(animate);
    cube.rotation.x += 0.01;
    cube.rotation.y += 0.01;
    cube2.rotation.x += 0.01;
    cube2.rotation.y += 0.01;
    renderer.render(scene, camera);
}
animate();

    </script>
</body>